\documentclass[10pt]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{enumitem}
\usepackage[margin=0.3in]{geometry}
\title{\textbf{CS 124: Operating Systems}}
\author{Justin Leong}
\date{\today}
\begin{document}

\maketitle
\setlength\parindent{0pt}
\setlist[description]{style=nextline,leftmargin=0cm}

\begin{description}
\section{Lecture 1 - 1/4/17}
\item[What is Pintos designed to run on?]
  IA34/x86 processor emulator (Bochs, QEMU)
\item[What is different between Pintos and the Linux kernel implementation]
  systems call implementation is different
\item[Which assignments are crucial?]
  3rd and 4th assignments; bonus points for building 6 on top of 5
\item[What should you do if the Bochs VM doesn't work?]
  try QEMU
\item[What is an OS?]
  an OS provides applications with a standardized interface to the computer's hardware resources;
  an OS manages the allocation and sharing of hardware resources to applications that want to use them
\item[What is an analogy for OS?]
  government - by itself there is no reason for it to exist but provides resources for useful things to be accomplished
\item[What did earlier disks use?]
  cylinder-head-sector(CHS) addressing
\item[What is used now?]
  Logical Block Addressing(LBA)
\item[What kinds of maintenance do different storage technologies require?]
  Magnetic disks are sensitive to fragmentation;
  SSDs have a constant seek time but memory blocks must be erased before they can be rewritten and the erase-block size is much larger than read/write blocks;
  and blocks can only be erased so many times before they weaaaar out;
  to minimize performance and wear issues, the filesystem must interact with SSDs differently than with magnetic disks
\item[What does the OS provide for Filesystems?]
  a standardized interface: open(), close(), read(), write();
  other devices use essentially the same interface (socket communications, console input/output, pipes between processes)
\item[In UNIX what happens when Process B deletes foo.txt while Process A is read/writing to it?]
  the OS remove sthe path to the file when process B deletes foo.txt but the actual file remains until process A terminates;
  when process A terminates, OS reclaims space used by foo.txt
\item[What was inefficient about mainframes and punch cards?]
  mainframe's CPU is sitting idle, blocked by I/O operations
\item[What is batch processing?]
  combining multiple punch cards into an input tape; job output saved to output tape
\item[What is inefficient about batch processing?]
  if job 1 is waiting for I/O to complete, the mainframe can't do anything else; CPU sits idle
\item[What was introduced to try to solve this?]
  multiprogramming - partition maingrame memory for jobs but must provide process isolation
\item[What was another problem with batch-rpocessing mainframes?]
  could take hours to discover a syntax error or bug
\item[What are timesharing systems?]
  extension of multipgoramming, allowing users to issue jobs directly on the mainframe, and receive their own output;
  first appearance of basic multitasking in an OS
\item[What happened to mainframes as integrated circuit tech bcame widespread?]
  minicomputers and then microcomputers replaced them for the individual user; GUIs were developed to make it easy for people to use computers;
  eventually multiple processors in a single computer - multiprocessor and multicore systems;
  operating system as an application within another operating system
\item[What are the different ways to have a host OS and guest OS?]
  emulation - computer with one CPU type simulates another CPU;
  virtualization - runs a guest OS compiled for the same CPU type; faster
\item[What is a hypervisor?]
  software that provides a virtual machine for the guest OS;
  guest OSes expect to access hardware directly; hypervisor must present this abstraction to guest OSes
\item[Is multiprocessor or multicore slower?]
  multiprocessor is slower because more physical distance
\item[When were the first big GUIs created?]
  1960s - Doug Englebart - demo-ed a GUI that included video conferencing and shared editing system
\item[What should we study?]
  virtual memory
\item[What do mainframe/server OSes worry about?]
  don't care aboug GUI; rather support very efficient handling of I/O and possibly scheduling a large number of processes
\item[What do PC OSes worry about?]
  be responsive and user-friendly
\item[What must OSes for mobile devices and tablets worry about?]
  same thing as PS plus maximize battery life; basic device capabilities must also be rock-solid reliable
\item[What is the most common kind of computer now?]
  embedded computer
\item[What are real-time operating systems?]
  focus on completing tasks by a specific deadline
\item[What is soft real-time support vs hard real-time guarantees?]
  soft is not considered a system failure if it misses; hard could be like an assembly line machine
\end{description}

\begin{description}
\section{Lecture 2 - OS Components Overview of Unix File I/O - 1/6/17}
\item[What are common components of OSes?]
  users, applications, operating system, computer hardware
\item[What are system applications?]
  services, command-line support, GUI
\item[What are user apps designed for?]
  to solve specific problems
\item[What facilities does the OS itself provide?]
  program execution (load and run programs, optionally runtime linking if shared libraries, program termination, pass along signals, etc.);
  resource allocation (memory, disk space, cpu);
  filesystems;
  I/O services (read blocks of data off hardware devices);
  communication (Inter-Process Communication (IPC));
  accounting facility (important for cloud services to bill people (AWS));
  error detection - degrade gracefully instead of crashing;
  protection security - all interactions with OS are performed via system calls
\item[Which two main features on computer processors allow operating systems to provide protection and security?]
  multiple processor operating modes (kernel mode, user mode);
  virtual memory - processor maps virtual addresses to physical addresses using page table
\item[What is a kernel?]
  part of OS that runs in kernel mode
\item[What are hierarchical protection domains or protection rings]
  Level 0 is kernel mode; level 3 is user mode;
  level 1 might run guest OSes
\item[How many protection levels do ARMv7(Advanced RISC Machines processors have?]
  8 different protection levels for different scenarios
\item[What can regions of memory be restricted to?]
  kernel-mode access only or allow user-mode access; called kernel space and user space
\item[Where can standard I/O/error streams come from?]
  console/terminal;
  redirected to/from disk files;
  redirected to/from another process
\item[Why do we have stdout and stderr?]
  IBM had a complicated etching program;
  result of plate just said syntax error;
  seperate stream to output errors
\item[What is all input-oputput performed with?]
  ssize\_t read(int filedes, void *buf, size\_t nbyte);
  ssize\_t write(int filedes, const void *buf, size\_t nbyte);
\item[What is ssize\_t vs size\_t?]
  size\_t is unsigned
\item[What happens during I/O?]
  context switching
\item[What is filedes?]
  file descriptor - index into array
\item[What does having v\_ptr give us?]
  it allows multiple processes to have the same file open;
  two v\_ptr's can point to the same struct in Global Kernel Data
\item[What are the file descriptors almost always?]
  file descriptor 0 = standard input;
  file descriptor 1 = standard output;
  file descriptor 2 = standard error;
  For sake of compatibility, always useee constants defined in unistd.h (STDIN\_FILENO, etc.)
\item[What cares about where stdin and stdout?]
  not programs;
  command shells care very much;
  grep Allow < logfile.txt > output.txt
\item[What is > vs >>?]
  > is write and truncate, >> is write and append
\item[How does the child process output to the command shell's standard output? How does it get the shell's stdin?]
  when a UNIX process is forked, it is a near-identical copy of the parent process;
  child process has all the same files open and the same file descriptor
\item[What does dup2 allow?]
  duplicates specified file desciptor into the descriptor specified by filedes2;
  allows command-shell's child process to redirect standard input and output
\end{description}

\begin{description}
\section{Lecture 3 - Hardware Details OS Design Patterns - 1/9/17}
\item[How do we prevent applications from accessing operating system state or code directly?]
  OS code and state are stored in kernel space and must be kernel mode to access this data;
  application code and state is in user space (can be manipulated in kernel mode)
\item[What is a trap?]
  intentional software-generated exception or interrupt;
  during OS initialization, kernel provides a handler to be invoked by the processor when the trap occurs;
  applications can invoke operating system subroutines without having to know what address they live at;
  int instruction on IA32; int \$0x80 used to make Linux system calls
\item[Why do different operating mode shave different stacks?]
  kernel won't be affected by misbehaving programs and kernel needs much smaller stack (KBs vs MBs)
\item[How are arguments/results passed to the interrupt handler?]
  in registers
\item[What happens if you change privilege levels in a int n instruction?]
  change to the appropriate stack
\item[What is iret?]
  performs same sequence of steps in reverse
\item[What allows exceptional control flow?]
  traps, interrupts (caused by hardware devices)
\item[What are faults?]
  usually unintentianal exceptions generated by attempting to execute a specific instruction
\item[What are aborts?]
  nonrecoverable hardware errors; e.g. IA32 machine-check exception, double-fault (trying to handle an interrupt/fault and then another fault occurs), triple-fault
\item[What is probably happening if you are stuck in a reboot loop?]
  generating triple faults (Project 4-6)
\item[What relies on hardware interrupts?]
  certain kinds of multitasking; preemptive multitasking
\item[What is cooperative multitasking?]
  each process voluntarily relinquishes the CPU, e.g. waiting for an IO operation, when it yields, or terminates
\item[What is the problem with cooperative multitasking? What is the solution?]
  malicious or badly designed programs won't relinquish the CPU;
  solution to incorporate a hardware timer(kernel-mode access) into the computer (preemptive multitasking)
\item[What handles hardware interrupts?]
  Local APIC; I/O APIC
\item[What do APICs allow processors to send to each other?]
  inter-processor interrupts (IPIs)
\item[How is hardware interrupt handling important with long-running I/O operations?]
  when I/O operation is finished, hardware fires an interrupt to notify the OS since context switching
\item[What does long running operations mean?]
  context switching
\item[What are hardware facilitiy requirements?]
  dual-mode operation, virtual memory management, ability to trap, support for software/hardware interrupts, hardware timer facility
\item[What is a guiding principle in OS design?]
  seperation of policy and mechanism (e.g. APIC on single vs multi-core systems)
\item[What is policy?]
  specifies what needs to be done; very likely to change
\item[What is mechanism?]
  specifies how to do it; unlikely to change substantially over time for a given OS and set of hardware
\item[What are the various structural patterns?]
  simple structure - no structure - anything can access anything;
\item[What are the problems of a simple structure?]
  highly susceptible to bugs and malicious programs, difficult to extend OS's functionality
\item[What was the problem with MS-DOS?]
  it used a simple structure because processors had no protected mode execution;
  resident programs could control hardware
\item[What mechanism did the initial versions of UNIX use as a design?]
  monolithic kernels - susceptible to bugs but fast
\item[How do you avoid the issues of monolithic OS's?]
  layered structure - higher layers rely on ops exposed by lower layers, layers can be tested in isolation
\item[When was the first layered strucutre OS implemented?]
  1965-68 by Edsger Dijkstra at THE(Technische Hogeschool Eindhoven), the THE OS
\item[What are the advantages of the layered structure?]
  resulted in a very reliable OS with a low rate of bugs
\item[What are the disadvantages of the layered structure?]
  takes a long time to design/implement, reduces OS performance
\item[What are the tradeoffs of layers?]
  make fewer layers with greater functionality
\item[What are modular kernels?]
  modern monolithic kernels use loadable kernel modules; modules will say what its dependencies are
\item[What are benefits of modular kernels?]
  retains high performance of monolithic kernels;
  encapsulate critical module state;
  smaller monolithic kernel
\item[What are drawbacks of modular kernels?]
  only slightly reduces reliability issues;
  modules run in kernel mode so bugs can cause OS to crash
\end{description}


\begin{description}
\section{Lecture 4 - OS Design Patterns II - 1/11/17}
\item[What general OS design patterns are there?]
  simple structure, layered structure, monolithic kernels, modular kernels
\item[What OS facilities actually require kernel-mode access?]
  only ones that must use privileged CPU capabilities
\item[What OS structural approach restricts the kernel to contain only a minimal set of capabilities?]
  microkernels - extremely small (< 10K lines of code)
\item[What facilities should be included in the kernel?]
  Jochen Liedtke's minimality principle - pull it out of microkernel unless you can't;
  Process abstraction: context switches, CPU scheduling, interrupt handling;
  Memory abstraction: process address-space isolation, kernel/user memory separation;
  Inter-process communication facilities: required to allow user-mode processes to work together
\item[What else does the microkernel need to faciliate?]
  drivers often require privileged I/O port access; process scheduling is often also supported
\item[What are the benefits of microkernels?]
  very reliable (small amount of kernel code);
  make services more resilient since reliability does not meant state is never lost;
  supporting multiprocessor or multiple-computer systems become very easy by extending IPC mechanism to support messages between processors;
\item[What are the drawbacks of microkernels?]
  performance - message-passing is asynchronous
\item[What was the problem with CMU Mach 3.0?]
  implemented on top of BSD Linux but performance was bad;
  different subsytems don't have all the details they need to make good choices
\item[How did Jochen Liedtke improve it?]
  completely new IPC mechanisms(L3, L4) which achieved order of magnitude improvement
\item[How did L4 improve Mach 3.0?]
  fewer system calls per IPC interaction, handles short and long IPC messages differently;
  performs direct process switch whenever possible;
  can negatively impact real-time guarantees since it isn't running scheduler;
  http://os.inf.tu-dresden.de/L4/
\item[What kernel structure replaced microkernels?]
  hybrid kernels which have same conceptual structure but move some services into kernel;
  MacOS X and Windows NT is a hybrid kernel
\item[What are exokernels?]
  Give applications direct control over hardware;
  XOmB, Nemesis, MIT XOS
\item[What are the 5 design patterns for OS's?]
  simple structure; layered structure;
  monolithic kernels, modular kernels;
  microkernels, hybrid kernels;
  exokernels
\end{description}

\begin{description}
\section{Lecture 5 - Bootstrap, PC Bios, and IA32 Memory Modes - 1/13/17}
\item[How do computers load the OS?]
  implement a bootstrap process - series of one or more boot-loaders
\item[How do modern computers load the OS?]
  typicaly use read-only memory containing initial code (ROM)
\item[How do old computers load the OS before ROM?]
  read limited intructions from external source then begin executing;
  punched-cards executed one at a time;
  bank of switches to specify first command;
  computers used diode matrixes (card with bunch of diodes - clip out diodes to put program in)
\item[What is firmware?]
  combination of persistent memory and the program stored in it
\item[What is PC BIOS?]
  original firmware for x86 computers;
\item[What two critical features, and a third useful one does PC BIOS provide?]
  firmware bootloader to start the bootstrap process;
  library of basic I/O functions for interacting with the computer hardware;
  simple UI for hardware config
\item[Why do you need to write bootloader in assembly code?]
  only 512 bytes in boot sector
\item[What is MBR?]
  mastor boot record - first sector of hard disk
\item[What do bootloaders rely on BIOS functions for?]
  interacting with hardware; all functions invoked via software interrupts
\item[What is the limitation of CHS addressing?]
  can only access 8 GiB
\item[what was introduced to fix this?]
  logical block addressing
\item[What is a segmented memory model?]
  can be segmented; segments meaning depends on memory addressing mode;
  real-addressing mode - generally only 16-bit registers, can use 32-bit registers on 32-bit platforms
  segments overlap in physical memory
\item[What do we want to use instead of real-addressing mode?]
  protected-mode;
  also uses the segment registers
\item[What is the Global Descriptor Table?]
  in protected mode, segment selectors not used directly, use GDT instead
\item[Why does virtual memory exist?]
  segments, not pages were used in the old days for memory
\end{description}

\begin{description}
\section{Lecture 6 - IA32 OS Startup UEFI firmware - 1/18/17}
\end{description}
\item[What is the IA32 Bootstrap process?]
  At power on, IA32 processor starts executing instructions at address 0xFFFFFFF0;
  BIOS bootstrap code performs a power-on self test;
  load first 512-byte sector of each bootable device at address 0x7C00;
  if MBR bootloader, chain-load boot sector;
  load OS kernel and jump to kernel bootstrap code
\item[What happens during the switch from real to protected mode?]
  switch from real-addressing mode to protected mode;
  check if A20 is disabled and then re-enable to access > 1 MiB of memory;
  some bootloaders (GRUB) and some BIOSes take care of this;
  Disable interrupts.
  Load the Global Descriptor Table Register (GDTR) with a pointer to the GDT containing the OS' segment descriptors.
  Load the Task Regisiter (TR) with a simple Task State Segment so that protected-mode interrupt handling will work properly.
  Turn on protected mode (enable virtual memory paging system).
  Force CPU to load new 32-bit protected mode segment selectors by performing a long-jump to the next instruction. (in protected mode after long jum)
  Set the other segment registers to the kernel-data segment selector value.
  Load the Interrupt Descriptor Table Register (IDTR) with a pointer to the interrupt descriptor table for the OS.
\item[What happens once we switch from real to protected mode?]
  OS kernel ready to take over
\item[What are plug-and-play buses?]
  PCI, USB, FireWire, PC Card/PCMCIA; OS identify and configures hardware devices automatically
\item[What is ACPI?]
  Advanced configuratio nand Power Interface standard for hardware discovery, config, power management, and monitoring;
  OS must search for ACPI Root System Descriptor Pointer
\item[How do you find the Root System Descriptor Pointer (RSDP)?]
  look for RSD PTR starting on 16-byte boundary, compute structure's checksum to verify it is 0
\item[What is Unified Extensible Firmware Interface (UEFI)?]
  replacement for BIOS since you can't use it after switching to protected mode;
  replaces old BIOS interface with new, modular, extensible firmware;
  prompted by 64-bit Intel Itanium processor, which couldn't run BIOS;
  still needed to support an OS - EUFI was developed as the firmware interface standard
\item[What is the EFI system partition?]
  first partition of a disk in the system
\item[What did Logical Block Addressing (LBA) replace?]
  CHS
\item[Why are GUID partition tables (GPT) important?]
  if it gets corrupted, you can't get to the rest of the data;
  maintain two GPTs at beginning and end of disk to reduce risk of corruption (doesn't work for SSD controller failure)
\end{document}
